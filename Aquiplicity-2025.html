<!DOCTYPE html>
<html>
<head>
    <title>Aquiplicity 2025 JavaScript (Patch & Blend)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #controls {
            display: flex;
            align-items: center;
            padding: 10px;
            flex-wrap: wrap;
        }
        #mainContainer {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #thumbnailStrip {
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 5px;
            border-right: 1px solid #ccc;
            background: #f0f0f0;
            width: 165px;
            flex-shrink: 0;
        }
        .thumbnail {
            width: 150px;
            height: 112px;
            object-fit: cover;
            margin-bottom: 5px;
            border: 1px solid #999;
            cursor: pointer;
        }
        .thumbnail:hover {
            border-color: #000;
        }
        #workingArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: auto;
        }
        canvas {
            border: 1px solid black;
            margin: 10px;
            max-width: 100%;
            max-height: 90vh;
        }
        #status {
            margin: 10px;
            font-family: Arial, sans-serif;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
        }
        .slider-container {
            margin: 0 15px;
            display: flex;
            align-items: center;
        }
        .slider-label {
            margin-right: 5px;
            font-family: Arial, sans-serif;
        }
        input[type="range"] {
            width: 100px;
        }
        .slider-value {
            margin-left: 5px;
            min-width: 30px;
            font-family: Arial, sans-serif;
        }
        .tracy-rose-button {
            background-color: #0066cc;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            box-shadow: 0 2px #004d99,
                       0 3px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 12px;
            transition: all 0.1s;
            margin: 0 5px;
        }
        .tracy-rose-button:hover {
            background-color: #0077e6;
        }
        .tracy-rose-button:active {
            box-shadow: 0 1px #004d99;
            transform: translateY(1px);
        }
        .reset-button {
            background-color: #cc0000;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            box-shadow: 0 2px #990000,
                       0 3px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 12px;
            transition: all 0.1s;
            margin: 0 5px;
        }
        .reset-button:hover {
            background-color: #e60000;
        }
        .reset-button:active {
            box-shadow: 0 1px #990000;
            transform: translateY(1px);
        }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="imageInput" multiple accept="image/*">
        <button id="composeButton" onclick="composeImages()" disabled>Compose!</button>
        <button class="reset-button" onclick="resetApplication()">Reset</button>
        <div class="slider-container">
            <span class="slider-label">T1:</span>
            <input type="range" id="threshold1" min="0.01" max="1.0" step="0.01" value="0.10">
            <span class="slider-value" id="threshold1-value">0.10</span>
        </div>
        <div class="slider-container">
            <span class="slider-label">T2:</span>
            <input type="range" id="threshold2" min="0.01" max="1.0" step="0.01" value="0.12">
            <span class="slider-value" id="threshold2-value">0.12</span>
        </div>
        <div class="slider-container">
            <span class="slider-label">T3:</span>
            <input type="range" id="threshold3" min="0.01" max="1.0" step="0.01" value="0.13">
            <span class="slider-value" id="threshold3-value">0.13</span>
        </div>
        <div id="status">Upload images to begin</div>
    </div>
    <div id="mainContainer">
        <div id="thumbnailStrip"></div>
        <div id="workingArea">
            <canvas id="canvasOutput"></canvas>
            <div>
                <button onclick="saveImage()">Save Master Image</button>
                <button class="tracy-rose-button" onclick="setTracyRosePreset()">By Tracy Rose</button>
            </div>
        </div>
    </div>
    
    <script type="text/javascript">
        function getThresholds() {
            const t1 = parseFloat(document.getElementById('threshold1').value) * 255;
            const t2 = parseFloat(document.getElementById('threshold2').value) * 255;
            const t3 = parseFloat(document.getElementById('threshold3').value) * 255;
            return [t1, t2, t3];
        }

        function setTracyRosePreset() {
            const sliders = ['threshold1', 'threshold2', 'threshold3'];
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(`${id}-value`);
                slider.value = 0.13;
                valueDisplay.textContent = '0.13';
            });
            status.textContent = 'Tracy Rose preset applied (all thresholds set to 0.13)';
            console.log('Tracy Rose preset applied: all sliders set to 0.13');
        }

        function resetApplication() {
            imgBase = null;
            imagesStack = [];
            masterImages = [];
            lassoPoints = [];
            drawingLasso = false;
            isPatchLasso = false;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = 0;
            canvas.height = 0;

            document.getElementById('imageInput').value = '';
            thumbnailStrip.innerHTML = '';
            composeButton.disabled = true;
            status.textContent = 'Upload images to begin';

            const sliderDefaults = {
                'threshold1': '0.10',
                'threshold2': '0.12',
                'threshold3': '0.13'
            };
            for (let [id, value] of Object.entries(sliderDefaults)) {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(`${id}-value`);
                slider.value = value;
                valueDisplay.textContent = value;
            }

            console.log('Application reset to initial state');
        }

        const PATCH_SIZE = 5;
        let canvas = document.getElementById('canvasOutput');
        let ctx = canvas.getContext('2d');
        let imgBase = null;
        let imagesStack = [];
        let status = document.getElementById('status');
        let composeButton = document.getElementById('composeButton');
        let thumbnailStrip = document.getElementById('thumbnailStrip');
        let originalWidth, originalHeight;
        let lassoPoints = [];
        let drawingLasso = false;
        let isPatchLasso = false;
        let masterImages = [];

        document.addEventListener('DOMContentLoaded', () => {
            if (!canvas || !ctx) {
                console.error('Canvas or context not initialized');
                status.textContent = 'Error: Canvas not initialized';
                return;
            }
            document.getElementById('imageInput').addEventListener('change', handleImageUpload);
            setupCanvasEvents();
            
            ['threshold1', 'threshold2', 'threshold3'].forEach(id => {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(`${id}-value`);
                slider.addEventListener('input', () => {
                    valueDisplay.textContent = slider.value;
                });
            });
            
            console.log('Page loaded, event listeners set up');
        });

        function fitToScreen(imgWidth, imgHeight) {
            const maxWidth = document.getElementById('workingArea').clientWidth - 40;
            const maxHeight = window.innerHeight * 0.9 - 40;
            const aspectRatio = imgWidth / imgHeight;

            let newWidth = imgWidth;
            let newHeight = imgHeight;

            if (newWidth > maxWidth) {
                newWidth = maxWidth;
                newHeight = newWidth / aspectRatio;
            }
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                newWidth = newHeight * aspectRatio;
            }

            return { width: Math.floor(newWidth), height: Math.floor(newHeight) };
        }

        function calculateRegionDifference(imgData1, imgData2, rect) {
            let totalDiff = 0;
            let pixelCount = 0;
            for (let y = rect.y; y < rect.y + rect.height; y++) {
                for (let x = rect.x; x < rect.x + rect.width; x++) {
                    if (x < imgData1.width && y < imgData1.height && x < imgData2.width && y < imgData2.height) {
                        const idx = (y * imgData1.width + x) * 4;
                        totalDiff += Math.sqrt(
                            Math.pow(imgData1.data[idx] - imgData2.data[idx], 2) * 0.299 +
                            Math.pow(imgData1.data[idx + 1] - imgData2.data[idx + 1], 2) * 0.587 +
                            Math.pow(imgData1.data[idx + 2] - imgData2.data[idx + 2], 2) * 0.114
                        );
                        pixelCount++;
                    }
                }
            }
            return pixelCount > 0 ? totalDiff / pixelCount : Infinity;
        }

        function isPointInLasso(x, y, points) {
            let inside = false;
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x, yi = points[i].y;
                const xj = points[j].x, yj = points[j].y;
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', (e) => {
                if (!masterImages.length || imagesStack.length < 2) return;

                const rect = canvas.getBoundingClientRect();
                const x = Math.floor(e.clientX - rect.left);
                const y = Math.floor(e.clientY - rect.top);

                if (e.ctrlKey) {
                    if (drawingLasso) return;
                    drawingLasso = true;
                    isPatchLasso = true;
                    lassoPoints = [{x, y}];
                    console.log('Patch lasso started at:', x, y);
                    status.textContent = 'Drawing invisible patch lasso (Ctrl held)...';
                } else if (e.altKey) {
                    if (drawingLasso) return;
                    drawingLasso = true;
                    isPatchLasso = false;
                    lassoPoints = [{x, y}];
                    console.log('Blend lasso started at:', x, y);
                    status.textContent = 'Drawing invisible blend lasso (Alt held)...';
                } else {
                    patchRegion(x, y);
                    status.textContent = 'Patch (5x5) applied at ' + x + ',' + y;
                    console.log('Patch applied at:', x, y);
                    displayMasterImage();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!drawingLasso || !masterImages.length) return;

                const rect = canvas.getBoundingClientRect();
                const x = Math.floor(e.clientX - rect.left);
                const y = Math.floor(e.clientY - rect.top);
                lassoPoints.push({x, y});
                redrawCanvasWithLasso();
            });

            canvas.addEventListener('mouseup', (e) => {
                if (!drawingLasso || !masterImages.length) return;
                drawingLasso = false;

                if (lassoPoints.length < 3) {
                    console.log('Lasso too small, aborted');
                    status.textContent = 'Lasso too small';
                    lassoPoints = [];
                    clearLassoAndRedraw();
                    return;
                }

                if (isPatchLasso) {
                    applyLassoPatch();
                } else {
                    applyLassoBlend();
                }
                lassoPoints = [];
                drawingLasso = false;
                clearLassoAndRedraw();
                console.log(`${isPatchLasso ? 'Patch' : 'Blend'} lasso completed and cleared`);
            });

            document.addEventListener('keyup', (e) => {
                if ((e.key === 'Control' || e.key === 'Alt') && drawingLasso) {
                    drawingLasso = false;
                    lassoPoints = [];
                    clearLassoAndRedraw();
                    console.log(`${e.key === 'Control' ? 'Patch' : 'Blend'} lasso cancelled`);
                    status.textContent = 'Lasso cancelled';
                }
            });
        }

        function redrawCanvasWithLasso() {
            ctx.putImageData(masterImages[0], 0, 0);
        }

        function clearLassoAndRedraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(masterImages[0], 0, 0);
            canvas.style.display = 'none';
            canvas.offsetHeight;
            canvas.style.display = 'block';
            window.requestAnimationFrame(() => {
                console.log('Forced repaint completed');
            });
            console.log('Lasso cleared, combined master image redrawn');
            status.textContent = `Combined master image displayed (${imagesStack.length} images merged) - Click to patch (5x5), Ctrl+click to patch lasso, Alt+click to blend lasso`;
        }

        function applyLassoPatch() {
            const minX = Math.max(0, Math.min(...lassoPoints.map(p => p.x)));
            const maxX = Math.min(canvas.width, Math.max(...lassoPoints.map(p => p.x)));
            const minY = Math.max(0, Math.min(...lassoPoints.map(p => p.y)));
            const maxY = Math.min(canvas.height, Math.max(...lassoPoints.map(p => p.y)));

            const patchRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };

            if (patchRect.width <= 0 || patchRect.height <= 0) {
                console.log('Invalid patch lasso region');
                status.textContent = 'Invalid patch lasso region';
                return;
            }

            let minDiff = Infinity;
            let bestImageData = null;
            const masterData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            let allDiffs = [];
            for (let i = 1; i < imagesStack.length; i++) {
                const diff = calculateRegionDifference(masterData, imagesStack[i], patchRect);
                allDiffs.push({ index: i, diff: diff });
                console.log(`Image ${i} (e.g., image${i}.jpg) difference from master image in patch lasso region: ${diff}`);
                if (diff < minDiff) {
                    minDiff = diff;
                    bestImageData = imagesStack[i];
                }
            }

            if (!bestImageData && allDiffs.length > 0) {
                allDiffs.sort((a, b) => a.diff - b.diff);
                bestImageData = imagesStack[allDiffs[0].index];
                console.log(`Fallback: Using image ${allDiffs[0].index} (e.g., image${allDiffs[0].index}.jpg) with min diff ${allDiffs[0].diff}`);
            }

            if (bestImageData) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(bestImageData, 0, 0);

                const newMasterData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let updatedPixels = 0;
                for (let y = minY; y < maxY; y++) {
                    for (let x = minX; x < maxX; x++) {
                        if (isPointInLasso(x, y, lassoPoints)) {
                            const idx = (y * canvas.width + x) * 4;
                            const tempData = tempCtx.getImageData(x, y, 1, 1).data;
                            newMasterData.data[idx] = tempData[0];
                            newMasterData.data[idx + 1] = tempData[1];
                            newMasterData.data[idx + 2] = tempData[2];
                            newMasterData.data[idx + 3] = tempData[3];
                            updatedPixels++;
                        }
                    }
                }
                masterImages[0] = newMasterData;
                console.log('Patch lasso applied, region:', patchRect, 'difference from master:', minDiff, 'pixels updated:', updatedPixels);
                status.textContent = 'Patch lasso applied';
            } else {
                console.log('No match found for patch lasso, no patch applied');
                status.textContent = 'No better match found for patch lasso';
            }
        }

        function applyLassoBlend() {
            const minX = Math.max(0, Math.min(...lassoPoints.map(p => p.x)));
            const maxX = Math.min(canvas.width, Math.max(...lassoPoints.map(p => p.x)));
            const minY = Math.max(0, Math.min(...lassoPoints.map(p => p.y)));
            const maxY = Math.min(canvas.height, Math.max(...lassoPoints.map(p => p.y)));

            const blendRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };

            if (blendRect.width <= 0 || blendRect.height <= 0) {
                console.log('Invalid blend lasso region');
                status.textContent = 'Invalid blend lasso region';
                return;
            }

            const masterData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let blendedData = ctx.createImageData(canvas.width, canvas.height);
            blendedData.data.set(masterData.data);

            let pixelValues = {};
            for (let y = minY; y < maxY; y++) {
                for (let x = minX; x < maxX; x++) {
                    if (isPointInLasso(x, y, lassoPoints)) {
                        const idx = (y * canvas.width + x) * 4;
                        pixelValues[`${x},${y}`] = {
                            r: [], g: [], b: [], a: []
                        };
                        for (let i = 0; i < imagesStack.length; i++) {
                            const imgData = i === 0 ? imgBase : imagesStack[i];
                            if (x < imgData.width && y < imgData.height) {
                                const dataIdx = (y * imgData.width + x) * 4;
                                pixelValues[`${x},${y}`].r.push(imgData.data[dataIdx]);
                                pixelValues[`${x},${y}`].g.push(imgData.data[dataIdx + 1]);
                                pixelValues[`${x},${y}`].b.push(imgData.data[dataIdx + 2]);
                                pixelValues[`${x},${y}`].a.push(imgData.data[dataIdx + 3]);
                            }
                        }
                    }
                }
            }

            let updatedPixels = 0;
            for (let y = minY; y < maxY; y++) {
                for (let x = minX; x < maxX; x++) {
                    if (isPointInLasso(x, y, lassoPoints)) {
                        const idx = (y * canvas.width + x) * 4;
                        const values = pixelValues[`${x},${y}`];
                        if (values.r.length > 0) {
                            blendedData.data[idx] = values.r.reduce((a, b) => a + b, 0) / values.r.length;
                            blendedData.data[idx + 1] = values.g.reduce((a, b) => a + b, 0) / values.g.length;
                            blendedData.data[idx + 2] = values.b.reduce((a, b) => a + b, 0) / values.b.length;
                            blendedData.data[idx + 3] = values.a.reduce((a, b) => a + b, 0) / values.a.length;
                            updatedPixels++;
                        }
                    }
                }
            }

            if (updatedPixels > 0) {
                masterImages[0] = blendedData;
                console.log('Blend lasso applied, region:', blendRect, 'pixels updated:', updatedPixels);
                status.textContent = 'Blend lasso applied (feathered pixels)';
            } else {
                console.log('No pixels blended for blend lasso');
                status.textContent = 'No pixels blended for blend lasso';
            }
        }

        function patchRegion(clickX, clickY) {
            const halfPatch = Math.floor(PATCH_SIZE / 2);
            const patchX = Math.max(0, Math.min(clickX - halfPatch, masterImages[0].width - PATCH_SIZE));
            const patchY = Math.max(0, Math.min(clickY - halfPatch, masterImages[0].height - PATCH_SIZE));
            const patchRect = { x: patchX, y: patchY, width: PATCH_SIZE, height: PATCH_SIZE };

            let minDiff = Infinity;
            let bestImageData = null;
            const masterPixel = ctx.getImageData(clickX, clickY, 1, 1);

            let allDiffs = [];
            for (let i = 1; i < imagesStack.length; i++) {
                const idx = (clickY * imagesStack[i].width + clickX) * 4;
                const diff = Math.abs(masterPixel.data[0] - imagesStack[i].data[idx]) +
                            Math.abs(masterPixel.data[1] - imagesStack[i].data[idx + 1]) +
                            Math.abs(masterPixel.data[2] - imagesStack[i].data[idx + 2]);
                allDiffs.push({ index: i, diff: diff });
                console.log(`Image ${i} (e.g., image${i}.jpg) difference from master image at patch point: ${diff}`);
                if (diff < minDiff) {
                    minDiff = diff;
                    bestImageData = imagesStack[i];
                }
            }

            if (!bestImageData && allDiffs.length > 0) {
                allDiffs.sort((a, b) => a.diff - b.diff);
                bestImageData = imagesStack[allDiffs[0].index];
                console.log(`Fallback: Using image ${allDiffs[0].index} (e.g., image${allDiffs[0].index}.jpg) with min diff ${allDiffs[0].diff}`);
            }

            if (bestImageData) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(bestImageData, 0, 0);
                ctx.drawImage(tempCanvas, patchRect.x, patchY, patchRect.width, patchRect.height,
                            patchRect.x, patchY, patchRect.width, patchRect.height);
                masterImages[0] = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            displayMasterImage();
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if (!files.length) {
                status.textContent = 'No files selected';
                console.log('No files selected');
                composeButton.disabled = true;
                thumbnailStrip.innerHTML = '';
                return;
            }

            status.textContent = `Loading ${files.length} image(s)...`;
            console.log(`Attempting to load ${files.length} image(s)`);
            imagesStack = [];
            let loaded = 0;
            let thumbnails = [];

            for (let i = 0; i < Math.min(files.length, 15); i++) {
                const file = files[i];
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        const tempCanvas = document.createElement('canvas');
                        if (!imgBase) {
                            originalWidth = img.width;
                            originalHeight = img.height;
                            const scaled = fitToScreen(img.width, img.height);
                            tempCanvas.width = scaled.width;
                            tempCanvas.height = scaled.height;
                            canvas.width = scaled.width;
                            canvas.height = scaled.height;
                            console.log('Base dimensions set:', scaled.width, 'x', scaled.height);
                        } else {
                            tempCanvas.width = canvas.width;
                            tempCanvas.height = canvas.height;
                        }

                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                        if (!imgBase) {
                            imgBase = imageData;
                            console.log('Base image loaded (e.g., Image0.jpg)');
                        }
                        imagesStack.push(imageData);
                        
                        const thumbCanvas = document.createElement('canvas');
                        thumbCanvas.width = 150;
                        thumbCanvas.height = 112;
                        const thumbCtx = thumbCanvas.getContext('2d');
                        thumbCtx.drawImage(img, 0, 0, 150, 112);
                        const thumbImg = new Image();
                        thumbImg.src = thumbCanvas.toDataURL('image/png');
                        thumbImg.className = 'thumbnail';
                        thumbImg.title = `Image ${loaded + 1}`;
                        thumbImg.dataset.index = loaded;
                        thumbnails.push(thumbImg);

                        loaded++;
                        console.log(`Image ${loaded} of ${files.length} loaded (e.g., image${loaded}.jpg)`);
                        if (loaded === files.length) {
                            thumbnailStrip.innerHTML = '';
                            thumbnails.forEach(thumb => {
                                thumbnailStrip.appendChild(thumb);
                            });
                            status.textContent = `${files.length} images loaded - click Compose! to stack`;
                            composeButton.disabled = false;
                            console.log(`Displayed ${thumbnails.length} thumbnails`);
                            if (files.length > 15) {
                                console.log(`Limited to 15 thumbnails, ${files.length - 15} additional images loaded but not shown in strip`);
                            }
                        }
                    };
                    
                    img.onerror = () => {
                        console.error(`Failed to load image ${i + 1} (e.g., image${i}.jpg)`);
                        status.textContent = 'Error: Failed to load an image';
                    };
                    
                    img.src = event.target.result;
                };
                
                reader.onerror = () => {
                    console.error(`FileReader error for image ${i + 1} (e.g., image${i}.jpg)`);
                    status.textContent = 'Error: Failed to read file';
                };
                
                reader.readAsDataURL(file);
            }
        }

        function composeImages() {
            if (!imgBase || imagesStack.length < 1) {
                status.textContent = 'No images loaded to compose';
                console.error('No images available for composition');
                return;
            }

            status.textContent = 'Composing images at multiple thresholds...';
            console.log('Starting composition with', imagesStack.length, 'images');

            const THRESHOLDS = getThresholds();
            masterImages = [];
            for (let threshold of THRESHOLDS) {
                let tempMaster = ctx.createImageData(imgBase.width, imgBase.height);
                tempMaster.data.set(imgBase.data);

                let totalChanges = 0;
                for (let i = 1; i < imagesStack.length; i++) {
                    const imageData = imagesStack[i];
                    let changes = 0;

                    for (let y = 0; y < imageData.height; y++) {
                        for (let x = 0; x < imageData.width; x++) {
                            const idx = (y * imageData.width + x) * 4;
                            const baseIdx = (y * imgBase.width + x) * 4;
                            
                            const maxDiff = Math.max(
                                Math.abs(imgBase.data[baseIdx] - imageData.data[idx]),
                                Math.abs(imgBase.data[baseIdx + 1] - imageData.data[idx + 1]),
                                Math.abs(imgBase.data[baseIdx + 2] - imageData.data[idx + 2])
                            );

                            if (maxDiff > threshold) {
                                tempMaster.data[idx] = imageData.data[idx];
                                tempMaster.data[idx + 1] = imageData.data[idx + 1];
                                tempMaster.data[idx + 2] = imageData.data[idx + 2];
                                tempMaster.data[idx + 3] = imageData.data[idx + 3];
                                changes++;
                            }
                        }
                    }
                    totalChanges += changes;
                    console.log(`Threshold ${threshold / 255 * 100}% - Image ${i} (e.g., image${i}.jpg): ${changes} pixels changed`);
                }
                masterImages.push(tempMaster);
                console.log(`Composition complete for threshold ${threshold / 255 * 100}%, total pixels changed: ${totalChanges}`);
            }

            console.log('Verifying image inclusion across thresholds:');
            for (let i = 1; i < imagesStack.length; i++) {
                let included = false;
                for (let threshold of THRESHOLDS) {
                    let changes = 0;
                    for (let y = 0; y < imagesStack[i].height; y++) {
                        for (let x = 0; x < imagesStack[i].width; x++) {
                            const idx = (y * imagesStack[i].width + x) * 4;
                            const baseIdx = (y * imgBase.width + x) * 4;
                            const maxDiff = Math.max(
                                Math.abs(imgBase.data[baseIdx] - imagesStack[i].data[idx]),
                                Math.abs(imgBase.data[baseIdx + 1] - imagesStack[i].data[idx + 1]),
                                Math.abs(imgBase.data[baseIdx + 2] - imagesStack[i].data[idx + 2])
                            );
                            if (maxDiff > threshold) changes++;
                        }
                    }
                    if (changes > 0) included = true;
                }
                console.log(`Image ${i} (e.g., image${i}.jpg) included: ${included}`);
            }

            const combinedMaster = ctx.createImageData(imgBase.width, imgBase.height);
            for (let i = 0; i < combinedMaster.data.length; i += 4) {
                let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
                for (let master of masterImages) {
                    rSum += master.data[i];
                    gSum += master.data[i + 1];
                    bSum += master.data[i + 2];
                    aSum += master.data[i + 3];
                }
                combinedMaster.data[i] = rSum / masterImages.length;
                combinedMaster.data[i + 1] = gSum / masterImages.length;
                combinedMaster.data[i + 2] = bSum / masterImages.length;
                combinedMaster.data[i + 3] = aSum / masterImages.length;
            }
            masterImages = [combinedMaster];

            displayMasterImage();
            console.log('Combined master image created using mean averaging of thresholds:', THRESHOLDS.map(t => (t / 255).toFixed(2)).join(', '));
        }

        function displayMasterImage() {
            if (!masterImages.length) {
                status.textContent = 'No master image to display';
                console.error('No master image available');
                return;
            }
            if (!masterImages[0].data || masterImages[0].data.length === 0) {
                status.textContent = 'Master image data is empty';
                console.error('Master image data is invalid');
                return;
            }

            console.log('Displaying combined master image, size:', masterImages[0].width, 'x', masterImages[0].height);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(masterImages[0], 0, 0);
            canvas.style.display = 'none';
            canvas.offsetHeight;
            canvas.style.display = 'block';
            window.requestAnimationFrame(() => {
                console.log('Forced repaint completed');
            });
            status.textContent = `Combined master image displayed (${imagesStack.length} images merged) - Click to patch (5x5), Ctrl+click to patch lasso, Alt+click to blend lasso`;
            console.log('Combined master image rendered to canvas');
        }

        function saveImage() {
            if (!masterImages.length) {
                status.textContent = 'No image to save';
                return;
            }
            const cleanCanvas = document.createElement('canvas');
            cleanCanvas.width = canvas.width;
            cleanCanvas.height = canvas.height;
            const cleanCtx = cleanCanvas.getContext('2d');
            cleanCtx.putImageData(masterImages[0], 0, 0);
            
            const link = document.createElement('a');
            link.download = 'combined_master.png';
            link.href = cleanCanvas.toDataURL('image/png');
            link.click();
            status.textContent = 'Combined master image saved (without lasso lines)';
            console.log('Combined master image saved without lasso lines');
        }
    </script>
</body>
</html>